Exercises

1. Write pseudocode for bubble sort.

A: //Psuedocode

FUNCTION bubbleSort(collection)
   REPEAT
     SET swapped to false
     FOR i = FIRST INDEX of collection to LAST INDEX of collection - 1
       IF collection[i] > collection[i + 1] THEN
         SET tmp to collection[i]
         SET collection[i] to collection[i + 1]
         SET collection[i + 1] to tmp
         SET swapped to true
       END IF
     END FOR
   UNTIL swapped is FALSE
   RETURN collection
 END FUNCTION

2. Write pseudocode for quicksort.

A: //Psuedocode

FUNCTION quickSort ( collection, start, end )
	IF ( start < end )
		partition ( collection, start, end ) RETURNING partitionIndex
		quickSort ( collection, start, partitionIndex-1)
		quickSort ( collection, partitionIndex+1, end )
	END IF
  END FUNCTION

  FUNCTION partition ( collection, start, end )
	SET pivot to collection[end]
	SET partitionIndex to collection[start]
	FOR i = start to end-1
		IF collection[i]  <= pivot	
			SWAP collection[i] with collection[partitionIndex]
		END IF
	END FOR
	SWAP collection[partitionIndex] with collection[end]
	RETURN partitionIndex
  END FUNCTION
		  	
3. We talked about time complexity in a previous checkpoint, and how to get an idea of the efficiency of an algorithm. After looking at the pseudocode for the above sorting methods, identify why merge sort and quick sort are much more efficient than the others. Walking through each algorithm with a few sample collections may help.

A: Both merge sort and quick sort uses divide and conquer stratergy. Divide and break up the problem into the smallest possible “subproblem”, of the exact same type. Conquer and tackle the smallest subproblems first. Find a solution that works and use that exact same technique to solve the larger subproblems - solve the problems recursively.

Merge sort:

Time complexity: O(nlogn) 

To implement a merge sort we need two pieces of functionality
	1. Divide the unsorted list into n sublists, each containing 1 element (a list of 1 element is considered sorted).
		2. Repeatedly merge sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list.

Because of this implementation, multiple run throughs of the data is eliminated, and also it tends to be a lot easier to sort two smaller, unsorted lists rather than sorting a single large, unsorted one. Because of these reasons, merge sort can be very efficient.

Also, merge sort has a space complexity of O(n), that is it needs a constant amount of extra memory, that is proportional to the amount of number of elements to be sorted.

Quick sort:

Time complexity:
O(nlogn) - average case running time
O(n2) - Worst case running time

Even though the worst case running time is O(n2), Quick sort is pretty fast and efficient in practical scenarios. The worst case running time of quick sort is almost always avoided by using what is known as a randomized version of quick sort. A randomized quick sort gives us 0(nlogn) running time with very high probability. Quick sort is also very space efficient and its cache performance is very high, as data is sorted in place. No extra memory needed.

4. All of the sorts addressed in this checkpoint are known as comparison sorts. Research bucket sort and explain how it works. What is the ideal input for bucket sort?

A: Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or recursively applying the bucket sorting algorithm.

Bucket sort works as follows:

	1. Set up an array of initially empty “buckets”
	2. Scatter: Go over the original array, putting each object in its bucket.
	3. Sort each non-empty bucket
	4. Gather: Visit the buckets in order and put all elements back into the original array.

Bucket sort is mainly useful when input is uniformly distributed over a range. For example, sorting a large set of floating point numbers which are in range from 0.0 to 1.0 and are uniformly distributed across the range.
